<!DOCTYPE html>
<html>
<head>
	<title>Blokus</title>
	<style>
		table {
		  border-collapse: collapse;
		  width: 600px;
		  height: 600px;
		}
		td {
		  border: 1px solid black;
		  width: 10px;
		  height: 10px;
		  text-align: center;
		}
		.red {
		  background-color: red;
		}
		.green {
		  background-color: green;
		}
		.blue {
		  background-color: blue;
		}
		.yellow {
		  background-color: yellow;
		}
		.piece-slider img {
		  max-height: 30px;
		}
	  </style>
</head>
<body>
	<div style="display: flex;" id="all">
		<div class="grid-container" id="grid">
			<table style="border-collapse: collapse; width: 600px; height: 600px;">
				{% for i, row in enumerate(board.grid) %}
					<tr>
					{% for j, color in enumerate(row) %}
						<td class="square" data-x="{{ i }}" data-y="{{ j }}" value="{{ square }}" dataset="originalColor: {{ color }};" style="background-color: {{ color }}; width: 10px; height: 10px;"></td>
					{% endfor %}
					</tr>
				{% endfor %}
			  </table>
		</div>
		<div class="piece-list">
			<form method="post" action="{{ url_for('place') }}", id="pieces">
			  <input type="hidden" id="x" name="x" value="">
			  <input type="hidden" id="y" name="y" value="">
			  <input type="hidden" id="name" name="name" value="">
			  <label for="piece">Select a piece:</label>
			  {% for piece in pieces %}
			  <li style="display: block; margin-right: 10px;">
				<input type="radio" id="{{ piece['name'] }}" name="piece" value="{{ piece['name'] }}">
				<label for="{{ piece['name'] }}"><img src="{{ url_for('static', filename='pics/' + piece['name'] + '.png') }}" alt="{{ piece['name'] }}" style="height: 30px;"></label>
			  </li>
			  {% endfor %}
			</form>
		  </div>		  
	</div>
	<script>

		// // Declare a variable to store the selected piece name
		let selectedPiece = ''
		// Get the form element with id="pieces"
		const form = document.getElementById('pieces');
		// Add a change event listener to the form element
		form.addEventListener('click', (event) => {
		// Check if the changed element is a radio item
		if (event.target.type === 'radio') {
			// Get the selected piece name from the radio buttons
			selectedPiece = event.target.value;
			// Set the selected piece name in the hidden input element with id="name"
			document.getElementById('name').value = selectedPiece;
		}
		});

		const pieces = {{ pieces | tojson }};
  
		function getCurrentPiece(selectedPiece) {
			// Find the piece in the pieces list with the matching name
			const matchingPiece = pieces.find(piece => piece.name === selectedPiece);

			if (matchingPiece) {
			// Return the matching piece
			return matchingPiece;
			} else {
			// If no matching piece is found, return a default piece with no shape
			return {
				color: 'black',
				shape: [[]]
			};
			}
		}

		// function checkValidPlacement(x, y, shape) {
		// 	const numRows = board.grid.length;
		// 	const numCols = board.grid[0].length;
		// 	const shapeHeight = shape.length;
		// 	const shapeWidth = shape[0].length;

		// 	// Check if the piece would extend beyond the bounds of the grid
		// 	if (parseInt(x) + shapeHeight > numRows || parseInt(y) + shapeWidth > numCols) {
		// 		return false;
		// 	}

		// 	// Check if any of the squares that the piece would cover are already filled
		// 	for (let i = 0; i < shapeHeight; i++) {
		// 		for (let j = 0; j < shapeWidth; j++) {
		// 			const row = parseInt(x) + i;
		// 			const col = parseInt(y) + j;
		// 			if (shape[i][j] === 1 && board.grid[row][col] !== 'white') {
		// 				return false;
		// 			}
		// 		}
		// 	}

		// 	// If neither of the above checks failed, the placement is valid
		// 	return true;
		// }

		const board = {{ board.__dict__ | tojson }}

		let prevX = -1;
		let prevY = -1;

		function refreshBoard(board) {
			// Reset the color of all the squares that the mouse passed over
			for (let i = 0; i < board.grid.length; i++) {
					for (let j = 0; j < board.grid[0].length; j++) {
						const square = document.querySelector(`[data-x="${i}"][data-y="${j}"]`);
						if (square) {
							square.style.backgroundColor = square.dataset.originalColor
						}
					}
				}
		}

		function isValidPlacement(board, piece, x, y) {
			const shape = piece.shape;
			const numRows = board.grid.length;
			const numCols = board.grid[0].length;

			for (let i = 0; i < shape.length; i++) {
				for (let j = 0; j < shape[0].length; j++) {
				const row = x + i;
				const col = y + j;

				if (row < 0 || row > numRows || col < 0 || col > numCols) {
					// The piece would go off the board
					return false;
				}
				}
			}

			// The placement is valid
			return true;
			}


		const grid = document.getElementById('grid');


		// Add a mouseover event listener to the grid element
		grid.addEventListener('mouseover', (event) => {
			const x = event.target.getAttribute('data-x');
			const y = event.target.getAttribute('data-y');

			// Check if the mouse has moved to a new square
			if (x !== prevX || y !== prevY) {

				refreshBoard(board)

				// Set the color of the new square the mouse is over
				const currentPiece = getCurrentPiece(selectedPiece);
				const shape = currentPiece.shape;
				if (isValidPlacement(board, currentPiece, parseInt(x), parseInt(y))) {
					for (let i = 0; i < shape.length; i++) {
						for (let j = 0; j < shape[0].length; j++) {
							if (shape[i][j] === 1) {
								const row = parseInt(x) + i;
								const col = parseInt(y) + j;
								console.log(row)
								console.log(col)
								const square = document.querySelector(`[data-x="${row}"][data-y="${col}"]`);
								if (square) {
									square.dataset.originalColor = square.style.backgroundColor
									square.style.backgroundColor = currentPiece.color;
								}
							}
						}
					}
				}

				// Update the previous location of the mouse
				prevX = x;
				prevY = y;
			}
		});


		// Select the grid element and add a click event listener to it
		grid.addEventListener('click', (event) => {
		// Check if the clicked element is a square element
		if (event.target.classList.contains('square')) {
			// Get the x and y coordinates from the square's data attributes
			const x = event.target.getAttribute('data-x');
			const y = event.target.getAttribute('data-y');

			// Set the x and y input values in the form
			document.getElementById('x').value = x;
			document.getElementById('y').value = y;
			document.getElementById('name').value = selectedPiece;

			// Submit the form programmatically to the /place endpoint
			fetch('/place', {
				method: 'POST',
				body: new FormData(form),
				}).then(response => {
				// Get the response as a text file
				return response.text();
				}).then(data => {

					// console.log(data)
					// console.log(board)

					grid.innerHTML = data

					// grid.innerHTML = data;

					document.getElementById('pieces').innerHTML = ''
					// No need to update the radio inputs since they are already rendered by the template

					document.getElementById('x').value = '';
					document.getElementById('y').value = '';

					// Reset the form element with id="form" to its default values
					document.getElementById('form').reset();
			// No need to update the radio inputs since they are already rendered by the template
				}).catch(error => {
			// Handle the error as needed
			});
		}
		});


	</script>
	
</body>
</html>





